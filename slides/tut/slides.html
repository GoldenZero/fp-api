<!DOCTYPE html>
<html>
  <head>
    <title>Excel Parser</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible

```

class: center, middle

# Excel Parser
Julien Truffaut â€¢ `@JulienTruffaut`

???
- notes here
- see https://remarkjs.com/#1

---
# Goals

- retrieve data from a spreadsheet using names
- use a safe API (no exception, no null)
- provide combinators to parse a case class hierarchy

# Not a Goal

- create a general excel parsing library

---
# Excel API: XSSFWorkbook

```scala
libraryDependencies += "org.apache.poi" % "poi-ooxml"  % "3.15"
```

```tut:silent
import org.apache.poi.xssf.usermodel.XSSFWorkbook

def load(fileName: String): XSSFWorkbook =
    new XSSFWorkbook(getClass.getClassLoader.getResourceAsStream(fileName))
```

```tut
val workbook = load("example.xlsx")
```

--

```


```

All codes and slides are available on github at `julien-truffaut/excel-parser`

---
# Excel API: Name

```tut
val oilProd = workbook.getName("OilProd")

val oilProdFormula = oilProd.getRefersToFormula
```

.center[![workbook](workbook.png)]

---
# Excel API: AreaReference

```tut:silent
import org.apache.poi.ss.SpreadsheetVersion.EXCEL97
import org.apache.poi.ss.util.AreaReference

val oilProdFormula = workbook.getName("OilProd").getRefersToFormula
```

```tut
val area = new AreaReference(oilProdFormula, EXCEL97)
val cellRefs = area.getAllReferencedCells

cellRefs.foreach(println)
```
---
# Excel API: Cell

```tut
val cellRef = cellRefs.head

val cell = workbook.getSheet(cellRef.getSheetName).
  getRow(cellRef.getRow).
  getCell(cellRef.getCol)
```

--

```tut
cell.getNumericCellValue
```

--

```tut:fail
cell.getStringCellValue
```

---
# Cell error handling

```tut:silent
sealed trait ParserError extends Product with Serializable

case class InvalidFormat(ref: String, expectedFormat: String,
                         message: String) extends ParserError
```

--

```tut:silent
import cats.syntax.either._
import org.apache.poi.xssf.usermodel.XSSFCell

case class SafeCell(cell: XSSFCell){
  def asDouble: Either[ParserError, Double] =
    Either.catchNonFatal(cell.getNumericCellValue).leftMap(e =>
      InvalidFormat(cell.getReference, "Numeric", e.getMessage)
    )

  def asString: Either[ParserError, String] =
    Either.catchNonFatal(cell.getStringCellValue).leftMap(e =>
      InvalidFormat(cell.getReference, "String", e.getMessage)
    )
}
```

---
# Cell error handling

```tut:silent
val safeCell = SafeCell(cell)
```

```tut
safeCell.asDouble
safeCell.asString
```

---
# API

```tut:silent
def numericRange(workbook: XSSFWorkbook,
                 name: String): Either[ParserError, List[Double]] = ???

def numeric(workbook: XSSFWorkbook,
            name: String): Either[ParserError, Double] = ???

def stringRange(workbook: XSSFWorkbook,
                name: String): Either[ParserError, List[String]] = ???

def string(workbook: XSSFWorkbook,
           name: String): Either[ParserError, String] = ???
```

```tut:fail:silent
numericRange(workbook, "OilProduction")
```

---
# API: Parsing Doubles

```tut:silent
import cats.syntax.traverse._
import cats.instances.either._
import cats.instances.list._

def numericRange(workbook: XSSFWorkbook,
                 name: String): Either[ParserError, List[Double]] = {
  val area  = new AreaReference(workbook.getName(name).getRefersToFormula, EXCEL97)
  val cells = area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  )

  val safeCells: List[SafeCell] = cells.map(SafeCell)
  val doubles: List[Either[ParserError, Double]] = safeCells.map(_.asDouble)
  doubles.sequenceU
}
```

---
# API: Parsing Doubles

```tut:silent
def numericRange(workbook: XSSFWorkbook,
                 name: String): Either[ParserError, List[Double]] = {
  val area = new AreaReference(workbook.getName(name).getRefersToFormula, EXCEL97)
  area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  ).map(SafeCell).traverseU(_.asDouble)
}
```

--

```tut
numericRange(workbook, "OilProd")
numericRange(workbook, "PrimaryProduct")
```

---
# API: Parsing Doubles

```tut:silent
def numericRange(workbook: XSSFWorkbook,
                 name: String): Either[ParserError, List[Double]] = {
  val area = new AreaReference(workbook.getName(name).getRefersToFormula, EXCEL97)
  area.getAllReferencedCells.toList.map(cellRef =>
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  ).map(SafeCell).traverseU(_.asDouble)
}
```

```tut:fail
numericRange(workbook, "foo")
```

---
# API: Parsing Doubles

```tut:silent
import org.apache.poi.ss.util.{AreaReference, CellReference}

sealed trait ParserError extends Product with Serializable

case class InvalidFormat(ref: String, expectedFormat: String, message: String) extends ParserError
case class MissingName(name: String) extends ParserError
case class MissingCell(ref: String) extends ParserError
```

```tut:invisible
case class SafeCell(cell: XSSFCell){
  def asDouble: Either[ParserError, Double] =
    Either.catchNonFatal(cell.getNumericCellValue).leftMap(e =>
      InvalidFormat(cell.getReference, "Numeric", e.getMessage)
    )

  def asString: Either[ParserError, String] =
    Either.catchNonFatal(cell.getStringCellValue).leftMap(e =>
      InvalidFormat(cell.getReference, "String", e.getMessage)
    )
}
```

```tut:silent
def getArea(workbook: XSSFWorkbook, name: String): Either[ParserError, AreaReference] =
  Either.catchNonFatal(
    new AreaReference(workbook.getName(name).getRefersToFormula, EXCEL97)
  ).leftMap(_ => MissingName(name))

def getSafeCell(workbook: XSSFWorkbook, cellRef: CellReference): Either[ParserError, SafeCell] =
  Either.catchNonFatal(SafeCell(
    workbook
      .getSheet(cellRef.getSheetName)
      .getRow(cellRef.getRow)
      .getCell(cellRef.getCol)
  )).leftMap(_ => MissingCell(cellRef.toString))
```

---
# API: Parsing doubles

```tut:silent
def numericRange(workbook: XSSFWorkbook, name: String): Either[ParserError, List[Double]] =
  for {
    area    <- getArea(workbook, name)
    cells   <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
    doubles <- cells.traverseU(_.asDouble)
  } yield doubles
```

```tut
numericRange(workbook, "OilProd")
numericRange(workbook, "PrimaryProduct")
numericRange(workbook, "foo")
```

---
# Parsing Product

```tut:silent
case class Production(oil: List[Double], gas: List[Double])

def production(workbook: XSSFWorkbook,
               oilName: String,
               gasName: String
               ): Either[ParserError, Production] = ???
```

---
# Parsing Product


```tut:silent
case class Production(oil: List[Double], gas: List[Double])

def production(workbook: XSSFWorkbook,
               oilName: String,
               gasName: String
               ): Either[ParserError, Production] =
  for {
    oil <- numericRange(workbook, oilName)
    gas <- numericRange(workbook, gasName)
  } yield Production(oil, gas)
```

---
# Parser

```tut:silent
trait Parser[A]{
  def parse(workbook: XSSFWorkbook): Either[ParserError, A]
}
```

--

```tut:silent
def numericRange(name: String): Parser[List[Double]] =
  new Parser[List[Double]]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, List[Double]] =
      for {
        area    <- getArea(workbook, name)
        cells   <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
        doubles <- cells.traverseU(_.asDouble)
      } yield doubles
  }
```

--

```tut:silent
def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] = ???
```

---
# Parsing Product

```tut:silent
def product[A, B](pa: Parser[A], pb: Parser[B]): Parser[(A, B)] =
  new Parser[(A, B)]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, (A, B)] =
      for {
        a <- pa.parse(workbook)
        b <- pb.parse(workbook)
      } yield (a, b)
  }
```

--

```tut:silent
val oil = numericRange("OilProd")
val gas = numericRange("GasProd")
val foo = numericRange("Foo")
```

```tut
product(oil, gas).parse(workbook)
product(oil, foo).parse(workbook)
```

---
# Parsing Product

```tut:silent
def map[A, B](pa: Parser[A])(f: A => B): Parser[B] =
  new Parser[B]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
      pa.parse(workbook).map(f)
  }
```

--

```tut:silent
val production = map(product(oil, gas)){case (oil, gas) => Production(oil,gas)}
```

```tut
production.parse(workbook)
```

---
# Parser is a Cartesian Functor

```tut:silent
trait Functor[F[_]]{
  def map[A,B](fa: F[A])(f: A => B): F[B]
}

trait Cartesian[F[_]]{
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}
```

--

```tut:invisible
import cats.{Monad, SemigroupK}

implicit val instance: Monad[Parser] with SemigroupK[Parser] = new Monad[Parser] with SemigroupK[Parser] {
    def combineK[A](x: Parser[A], y: Parser[A]): Parser[A] = new Parser[A] {
      def parse(workbook: XSSFWorkbook): Either[ParserError, A] =
        x.parse(workbook) orElse y.parse(workbook)
    }

    def flatMap[A, B](fa: Parser[A])(f: A => Parser[B]): Parser[B] =
      new Parser[B] {
        def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
          fa.parse(workbook).flatMap(f(_).parse(workbook))
      }

    def tailRecM[A, B](a: A)(f: A => Parser[Either[A, B]]): Parser[B] = new Parser[B] {
      def parse(workbook: XSSFWorkbook): Either[ParserError, B] = {
        def loop(thisA: A): Either[ParserError, B] = f(thisA).parse(workbook) match {
          case Left(a1)        => Left(a1)
          case Right(Left(a1)) => loop(a1)
          case Right(Right(b)) => Right(b)
        }
        loop(a)
      }
    }

    def pure[A](a: A): Parser[A] = new Parser[A]{
      def parse(workbook: XSSFWorkbook) = Right(a)
    }
  }
```

```tut:silent
import cats.syntax.all._

val oil = numericRange("OilProd")
val gas = numericRange("GasProd")

val production = (oil |@| gas).map(Production)
```

--

```tut:silent
(oil |@| gas |@| foo)
```

---
# Coproduct

```tut:silent
sealed trait Fee extends Product with Serializable
case class TechnicalFee(technical: Double) extends Fee
case class ExplorationFee(exploration: Double, postExploration: Double) extends Fee
```

--

```tut:invisible
def numeric(name: String): Parser[Double] =
  new Parser[Double]{
    def parse(workbook: XSSFWorkbook) =
      for {
        area    <- getArea(workbook, name)
        cells   <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
        double  <- cells.head.asDouble
      } yield double
  }
```

```tut:silent
val technicalFee: Parser[TechnicalFee] =
  numeric("TechnicalFee").map(TechnicalFee)

val explorationFee: Parser[ExplorationFee] =
  (numeric("ExplorationFee") |@| numeric("PostExplorationFee")).
    map(ExplorationFee)
```

--

```tut
technicalFee.parse(workbook)
explorationFee.parse(workbook)
```

```tut:fail:silent
val fee: Parser[Fee] = ???
```

---
# Combine

```tut:silent
def combine[A](p1: Parser[A], p2: Parser[A]): Parser[A] = new Parser[A]{
  def parse(workbook: XSSFWorkbook): Either[ParserError, A] =
    p1.parse(workbook) orElse p2.parse(workbook)
}
```

--

```tut:fail
val fee = combine(technicalFee, explorationFee)
```

---
# Combine

```tut:silent
val fee = combine(
  technicalFee.map(f => f: Fee),
  explorationFee.map(f => f: Fee)
)
```

--

```tut:silent
val fee = combine(
  technicalFee.widen[Fee],
  explorationFee.widen[Fee]
)
```

```tut
fee.parse(workbook)
```

---
# Parser is a SemigroupK

```scala
trait SemigroupK[F[_]]{
  def combineK[A](x: F[A], y: F[A]): F[A]
}

trait Semigroup[A]{
  def combineK(x: A, y: A): A
}
```

```tut:silent
val fee = technicalFee.widen[Fee] <+> explorationFee.widen[Fee]
```

```tut
fee.parse(workbook)
```

---
# API: Parsing String

```tut:silent
def stringRange(workbook: XSSFWorkbook, name: String): Either[ParserError, List[String]] =
  for {
    area    <- getArea(workbook, name)
    cells   <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
    strings <- cells.traverseU(_.asString)
  } yield strings
```

--

```tut:silent
def numericRange(workbook: XSSFWorkbook, name: String): Either[ParserError, List[Double]] =
  for {
    area    <- getArea(workbook, name)
    cells   <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
    doubles <- cells.traverseU(_.asDouble)
  } yield doubles
```

---
# API: Parsing Cells

```tut:silent
def range(workbook: XSSFWorkbook, name: String): Either[ParserError, List[SafeCell]] =
  for {
    area  <- getArea(workbook, name)
    cells <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
  } yield cells

def numericRange(workbook: XSSFWorkbook, name: String): Either[ParserError, List[Double]] =
  range(workbook, name).flatMap(_.traverseU(_.asDouble))

def stringRange(workbook: XSSFWorkbook, name: String): Either[ParserError, List[String]] =
  range(workbook, name).flatMap(_.traverseU(_.asString))
```

---
# Combining parsers

```tut:silent
case class Production(oil: List[Double], gas: List[Double])

def production(workbook: XSSFWorkbook,
               oilName: String,
               gasName: String
               ): Either[ParserError, Production] = ???
```

--

```tut:silent
def numericRange(workbook: XSSFWorkbook,
                 name: String): Either[ParserError, List[Double]] =
  range(workbook, name).flatMap(_.traverseU(_.asDouble))
```

---
# Parser

```tut:silent
trait Parser[A]{
  def parse(workbook: XSSFWorkbook): Either[ParserError, A]
}
```

--

```tut:silent
def range(name: String): Parser[List[SafeCell]] =
  new Parser[List[SafeCell]]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, List[SafeCell]] =
      for {
        area  <- getArea(workbook, name)
        cells <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
      } yield cells
  }
```

--

```tut:fail:silent
def numericRange(name: String): Parser[List[Double]] =
  range(name).flatMapF(cells => cells.traverseU(_.asDouble))
```

---
# Map / FlatMap

```tut:silent
trait Parser[A]{ self =>
  def parse(workbook: XSSFWorkbook): Either[ParserError, A]

  def map[B](f: A => B): Parser[B] = new Parser[B]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
      self.parse(workbook).map(f)
  }

  def flatMap[B](f: A => Parser[B]): Parser[B] = new Parser[B] {
    def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
      self.parse(workbook).flatMap(f(_).parse(workbook))
  }

   def flatMapF[B](f: A => Either[ParserError, B]): Parser[B] =
    flatMap(a =>
      new Parser[B] {
        def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
          f(a)
      }
    )
}
```

---
# Combining parsers

```tut:invisible
def range(name: String): Parser[List[SafeCell]] =
  new Parser[List[SafeCell]]{
    def parse(workbook: XSSFWorkbook): Either[ParserError, List[SafeCell]] =
      for {
        area  <- getArea(workbook, name)
        cells <- area.getAllReferencedCells.toList.traverseU(getSafeCell(workbook, _))
      } yield cells
  }
```

```tut:silent
def numericRange(name: String): Parser[List[Double]] =
  range(name).flatMapF(cells => cells.traverseU(_.asDouble))
```

```tut
numericRange("OilProd").parse(workbook)
```

--

```tut:silent
val production: Parser[Production] =
  for {
    oil <- numericRange("OilProd")
    gas <- numericRange("GasProd")
  } yield Production(oil, gas)
```

```tut
production.parse(workbook)
```

---
# Coproduct

```tut:silent
sealed trait PrimaryProduct extends Product with Serializable
case object Oil extends PrimaryProduct
case object Gas extends PrimaryProduct
```

--

```tut:silent
def single(name: String): Parser[SafeCell] = ???
```

```tut:invisible
def single(name: String): Parser[SafeCell] = new Parser[SafeCell] {
    def parse(workbook: XSSFWorkbook): Either[ParserError, SafeCell] =
      for {
        area  <- getArea(workbook, name)
        _     <- if(area.getAllReferencedCells.length == 1) Right(())
                 else Left(InvalidFormat(name, "single", "a single value"))
        cell  <- getSafeCell(workbook, area.getFirstCell)
      } yield cell
  }

def numeric(name: String): Parser[Double] =
  single(name).flatMapF(_.asDouble)
```

```tut:silent
def string(name: String): Parser[String] =
  single(name).flatMapF(_.asString)
```

--

```tut
string("PrimaryProduct").parse(workbook)
```

---
# Coproduct

```tut:silent
sealed trait PrimaryProduct extends Product with Serializable
case object Oil extends PrimaryProduct
case object Gas extends PrimaryProduct

val primaryProduct: Parser[PrimaryProduct] =
  string("PrimaryProduct").flatMapF{
    case "Oil" => Right(Oil)
    case "Gas" => Right(Gas)
    case other => Left(InvalidFormat("PrimaryProduct", other, "expected Oil or Gas"))
  }
```


--

```tut
primaryProduct.parse(workbook)
```

---
# Complex Coproduct

```tut:silent
sealed trait Fee extends Product with Serializable
case class TechnicalFee(technical: Double) extends Fee
case class ExplorationFees(exploration: Double, postExploration: Double) extends Fee
```

--

```tut:silent
val technicalFee: Parser[TechnicalFee] =
  numeric("TechnicalFee").map(TechnicalFee)

val explorationFees: Parser[ExplorationFees] = for {
  exploration     <- numeric("ExplorationFee")
  postExploration <- numeric("PostExplorationFee")
} yield ExplorationFees(exploration, postExploration)
```

```tut:fail:silent
val fee: Parser[Fee] = ???
```

```tut
technicalFee.parse(workbook)
explorationFees.parse(workbook)
```

---
# Or

```tut:silent
def or[A](p1: Parser[A], p2: Parser[A]): Parser[A] = new Parser[A]{
  def parse(workbook: XSSFWorkbook): Either[ParserError, A] =
    p1.parse(workbook) orElse p2.parse(workbook)
}

val fee: Parser[Fee] = or(
  technicalFee.map(f => f: Fee),
  explorationFees.map(f => f: Fee)
)
```

```tut
fee.parse(workbook)
```

---
# Parser typeclasses

```tut:silent
import cats.{Monad, SemigroupK}

implicit val instance: Monad[Parser] with SemigroupK[Parser] = new Monad[Parser] with SemigroupK[Parser] {
  def combineK[A](x: Parser[A], y: Parser[A]): Parser[A] = or(x, y)

  def flatMap[A, B](fa: Parser[A])(f: A => Parser[B]): Parser[B] = fa.flatMap(f)

  def pure[A](a: A): Parser[A] = new Parser[A]{
    def parse(workbook: XSSFWorkbook) = Right(a)
  }

  def tailRecM[A, B](a: A)(f: A => Parser[Either[A, B]]): Parser[B] = ???
}
```

```tut:invisible
implicit val instance: Monad[Parser] with SemigroupK[Parser] = new Monad[Parser] with SemigroupK[Parser] {
    def combineK[A](x: Parser[A], y: Parser[A]): Parser[A] = new Parser[A] {
      def parse(workbook: XSSFWorkbook): Either[ParserError, A] =
        x.parse(workbook) orElse y.parse(workbook)
    }

    def flatMap[A, B](fa: Parser[A])(f: A => Parser[B]): Parser[B] =
      new Parser[B] {
        def parse(workbook: XSSFWorkbook): Either[ParserError, B] =
          fa.parse(workbook).flatMap(f(_).parse(workbook))
      }

    def tailRecM[A, B](a: A)(f: A => Parser[Either[A, B]]): Parser[B] = new Parser[B] {
      def parse(workbook: XSSFWorkbook): Either[ParserError, B] = {
        def loop(thisA: A): Either[ParserError, B] = f(thisA).parse(workbook) match {
          case Left(a1)        => Left(a1)
          case Right(Left(a1)) => loop(a1)
          case Right(Right(b)) => Right(b)
        }
        loop(a)
      }
    }

    def pure[A](a: A): Parser[A] = new Parser[A]{
      def parse(workbook: XSSFWorkbook) = Right(a)
    }
  }
```

---
# Parser with typeclasses

```tut:silent
import cats.syntax.all._

val fee: Parser[Fee] = technicalFee.widen[Fee] <+> explorationFees.widen[Fee]
```

```tut
fee.parse(workbook)
```

--

```tut:silent
val production: Parser[Production] =
  (numericRange("OilProd") |@| numericRange("GasProd")).map(Production)
```

```tut
production.parse(workbook)
```


---
class: center, middle

# Thanks!
Code and slides at `julien-truffaut/excel-parser` on GitHub

## Questions?





 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
